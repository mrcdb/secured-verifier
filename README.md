 Introduction

The code in this repository is used to create a Third-Party Verifier, which is able to perform TCG compliant remote attestation operation on the node(s) pre-registered to it.

The verifier hosts four services, remote attestation server, IMA reference database, periodic attestation tasks, web service publishes the attestation result.

The remote attestation server is using [OpenAttestation v1.7](https://github.com/OpenAttestation/OpenAttestation/tree/v1.7) with additional tools to find the IMA measurements in the integrity report sent from the node to the verifier in the reference database.

The reference database is hosted using [apache-cassandra-1.2.19](http://cassandra.apache.org/), with customised modules to compare the 
package's versions, and store them in order in the reference database.


##Framework components

Logically, there are 2 mandatory components running in the attester, which are IMA and RA agent. While in the verifier there are appraiser, PrivacyCA, IMA verification script and IMA measure reference database. 

The interactions of each components are illustrated in 

![RA framework architecture](./img/architecture.pdf)

and in

![RA framework components](./img/racomponents.pdf)


To be more specific, the required components in our framework are the following:

- TPM, the core of our solution, which is the hardware root of trust;
- RA agent, which is in charge of generating integrity evidence and interacting with the verifier;
- IMA, which is mandatory to measure structural data (i.e. files) when they are loaded into memory;
- (Privacy) CA provisions and certifies attesting platformâ€™s AIK, which is required to identify the generator of the integrity evidence;
- Appraiser is the orchestrator of the overall attestation process and it is the one that actually evaluates the integrity evidence from each attester and gives result;
- WhiteList table is a collection of trusted PCR values, it can be derived from a clean setup state;
- IMA measure reference database is a collection of trusted IMA measures, it can be derived from a clean setup state or from packages released from their official repositories.

### Workflow 

#### Registration phase

The interactions occurred in the registration phase between the attester and the verifier are illustrated in ![Remote attestation registration phase](./img/ra-reg.pdf)

#### Attestation phase

The interactions occurred in the attestation phase between the attester and the verifier are illustrated in ![Remote attestation phase](./img/ra-dia.pdf)

###Protocols
There is no specified requirement for the protocol between the attester and the verifier, because the content of the integrity report can be authenticated by the signature generated by the TPM.
However, it is still possible to use TLS (the protocol used in https connection between the attester and the verifier) in order to protect the integrity report generated by the attester. 

# Verifier
The verifier is also deployed on a CentOS7 virtual machine. It is a computing intensive entity, the minimum spec is 2 CPU cores @ 2.66Ghz + 4GB memory + 4GB swap, the recommended spec is 4 cores @ 3392.142MHz + 4GB memory + 4GB swap.

For the sake of easy usage, it could be better to assign a large harddisk for the verifier, e.g. 100GB. Because when it is the first time to prepare the reference database, all packages for a single distribution need to be downloaded to be processed.

## Dependencies

The dependencies are for CentOS 7 minimal installation, which may have duplicates if the desktop or server version is used.

```bash
yum install epel-release
    
yum install ant trousers trousers-devel php-soap mariadb \
    mariadb-server python-networkx python-suds python-matplotlib \
    graphviz-devel patch java-1.7.0-openjdk java-1.7.0-openjdk-devel \
    zip unzip gcc gcc-c++ rpm-build python-pip git httpd php \
    php-mysql rpm-devel rabbitmq-server mod_ssl \
    mysql-connector-python 
    
pip install pycassa pygraphviz Celery urllib3 requests tornado
```    

## Installation steps:
It is assumed that the initial directory is `BASEDIR/verifier` and all files are cloned to this directory from the SECURED verifier repository.


1.	map the verifier's ip address into `/etc/hosts` and change the local host name
	to 'verifier', to simplify the future setup;
	
	it is also possible not to change the hostname to verifier, but all commands to send request to the verifier need to be changed accordingly.

	```bash
	root@verifier# echo -e 'xxx.xxx.xxx.xxx \t verifier' >> /etc/hosts
	root@verifier# echo 'verifier' > /etc/hostname
	```

	attestation requests are sent to the host named verifier.

2. 	go to `BASEDIR/verifier/OpenAttestation/Source` directory, run
	`distribute_jar_packages.sh`;

	```bash
	root@verifier# cd BASEDIR/verifier/OpenAttestation/Source
	root@verifier# bash distribute_jar_packages.sh
	```

3. 	go to `BASEDIR/verifier/OpenAttestation/Installer` directory, run `rpm.sh` to
	compile the OAT-appraiser package;

	```bash
	root@verifier# cd BASEDIR/verifier/OpenAttestation/Installer
	root@verifier# sh rpm.sh -s BASEDIR/verifier/OpenAttestation/Source
	```
	exactly from this directory, otherwise it does not work.

4.	install the package of `/root/rpmbuild/RPMS/x86_64/OAT-Appraiser-Base-OATapp-1.0.0-2.el7.centos.x86_64.rpm`;

	``` bash
	root@verifier# systemctl start mariadb
	root@verifier# systemctl enable mariadb
	root@verifier# cd /root/rpmbuild/RPMS/x86_64/
	root@verifier# yum localinstall OAT-Appraiser-Base-OATapp-1.0.0-2.el7.centos.x86_64.rpm
	root@verifier# systemctl daemon-reload
	```
	run this step only when mariadb service is running, because during installation phase, OAT will create database `oat_db` in mariadb.

5.	go to `BASEDIR/verifier/OpenAttestation/CommandTool` directory, and generate the CA certificate which will be used to access the OpenAttestation's services;

	```bash
	user@verifier$ cd BASEDIR/verifier/OpenAttestation/CommandTool
	user@verifier$ bash oat_cert -h verifier
	```

6.	and configure OpenAttestation with the `configure_oat.sh` following this format;

	``` bash
	user@verifier$ bash configure_oat.sh $selfname $attestorname $attestorIP $PCR0value $OSdistname $RApath $DBIP $CERTDGST
	```

	example:

	```bash
	bash configure_oat.sh verifier node xxx.xxx.xxx.xxx 7D94A15BE0295A3743FC259B07202FF42550B369 CentOS7 /root/ratools-tclouds/verifier/v2/ra_verifier.py xxx.xxx.xxx.xxx 8b71648e9c52a24cfe259305c611483ea56ca4dc
	```

	$selfname is 'verifier' by default, it is the host accepting the attestation requests

	$attestorname is the attestor's hostname, which will be used in the attestation requests

	$attestorIP is the IP address of the attestor, which will be linked the $attestorname

	$PCR0value is the value in the PCR0 slot in the TPM, which is used as a golden value with VALIDATE_PCR command

	$OSdistname is the distribution of the OS running in the attestor, which will be used in the attestation analysis

	$RApath is the path to the ra_verifier.py script, which is used to analyse the IMA measurements

	$DBIP is the ip of the reference database, if the database is running inside the same machine, please just put `localhost`

	$CERTDGST is the SHA1 digest of the file containing the strongSwan certificate used for node to authenticate itself (i.e. peerCert.der)

7. 	open ports for receiving/sending integrity reports, default ports are 80 and 8443

	``` bash
	root@verifier# firewall-cmd --permanent --add-port=80/tcp
	root@verifier# firewall-cmd --add-port=80/tcp
	root@verifier# firewall-cmd --permanent --add-port=8443/tcp
	root@verifier# firewall-cmd --add-port=8443/tcp
	```

8. 	change `/etc/oat-appraiser/OAT.properties` to store integrity reports in files, receive delta reports and discard identical integrity reports;

	uncomment IR_DIR, IR_DIGEST_METHOD, SCALABILITY, DISCARD_IDENTICAL_IR

9. 	to check if the verifier is working, use a browser to access the verifier's reference portal in the following link address:

	`http://verifier/OAT/alerts.php`

	In case of 403 Forbidden error, needs to change the permission of `/var/www/html/OAT`.

10. in this step, the node need to be configured;

	read guidelines below;

11. install cassandra reference database;

	```bash
	root@verifier# cd BASEDIR/verifier/db/install
	root@verifier# tar -xvzf apache-cassandra-1.2.19-bin.tar.gz
	root@verifier# ./install_cassandra_libs.sh BASEDIR/verifier/db/install/apache-cassandra-1.2.19
	```

12. initialise the reference database with the schema used to store the information;

	```bash
	root@verifier# cd BASEDIR/verifier/db/install/apache-cassandra-1.2.19/bin
	root@verifier# ./cassandra > /dev/null
	root@verifier# ./cassandra-cli -h localhost -f BASEDIR/verifier/db/install/cassandra/schema/cassandra-schema-common.txt
	root@verifier# ./cassandra-cli -h localhost -f BASEDIR/verifier/db/install/cassandra/schema/cassandra-schema-rpm.txt
	```

13. copy configuration files into `/etc/ra`;

	```bash
	root@verifier# mkdir /etc/ra
	root@verifier# cp BASEDIR/verifier/db/conf/pkgs_download_list.conf.sample /etc/ra/pkgs_download_list.conf
	root@verifier# cp BASEDIR/verifier/db/conf/ra.conf.sample /etc/ra/ra.conf
	```
These two files are configuration files, the data needs to be changed accordingly, especially `RABASEDIR` and `pkgs_download_list.conf`, the version (e.g. 7.3.1611) of distribution must present in the official online repository.

14. create `Packages` directory, go to `scripts` directory and run `update_pkgs.sh`;

	```bash
	root@verifier# mkdir BASEDIR/verifier/Packages
	root@verifier# cd BASEDIR/verifier/db/scripts
	root@verifier# bash update_pkgs.sh
	```
15. when the database is created, please use the `ra_verifier.py` script to test it;

	```bash
	root@verifier# cd BASEDIR/verifier/v2
	root@verifier# ./ra_verifier.py -i BASEDIR/verifier/db/measurements/ascii_runtime_measurements -q CentOS7 -a "load-time,l_req=l4|>=" -v -H localhost
	```
Should see information like following:
	```bash
	Info: 0 (0/0)
	0 (0/0)
	0
	0

	Info: 0.00266
	0.24042
	0.07041
	0.11005
	0
	0.42355
	```

16. start the command in CommandTool to poll the integrity reports and verify it as defined in the configure.sh script;

	``` bash
	root@verifier# bash oat_pollhosts -h verifier '{"hosts":["node"],"analysisType":"load-time+check-cert,l_req=l4_ima_all_ok|==,cert_digest=095b7792c076d65a9c45f4f484d06cd1fa29a9ba"}'
	```

17. if returned result is 'untrusted', which means the attestation feature is actually working, but there are some unknown digests in the IMA measurement list. In order to see which are unknown digests, run the following command:

	```python
	URL=https://verifier:8443/HisWebServices/hisDownloadReportService?wsdl IR=177 OS=CentOS7 /BASEDIR/verifier/v2/ra_verifier.py -H localhost -a "load-time+check-cert,l_req=l4_ima_all_ok|==,cert_digest=095b7792c076d65a9c45f4f484d06cd1fa29a9ba" -v
	```
You need to change the IR to the id received in the previous command (i.e. pollhosts) and also the cert_digest to the one measured in the node.
For unknown digests, two possible solutions. First, insert unknown digests in the whilelist, which is stored in ``/BASEDIR/verifier/v2/structs.py`, called known_digests. If multiple unknown digests are from a same package, which is not installed from the official repository, then you can insert the package manually as a 'testing' package with following command:
	```bash
	user@verifier$ bash /BASEDIR/verifier/db/scripts/update_pkgs.sh -d temp/ -t testing -n CentOS -q 7 -c x86_64
	```
Where `temp` directory is used for storing the testing packages.

18. to update the certificate used by strongSwan in the node, the information of this node needs to be updated;

	```bash
	root@verifier:# bash update_cert.sh $selfname $attestorname $attestorIP $OSdistname $CERTDGST
	```
example: 
    ```bash 
	user@verifier$ update_cert.sh verifier node xxx.xxx.xxx.xxx CentOS7 8b71648e9c52a24cfe259305c611483ea56ca4dc
    ```

19. to configure periodic attestation task; first need to configure `rabbitmq-server`

	```bash
	root@verifier:# rabbitmqctl add_user user secured
	root@verifier:# rabbitmqctl add_vhost uservhost
	root@verifier:# rabbitmqctl set_permissions -p uservhost user ".*" ".*" ".*"
	root@verifier:# systemctl enable rabbitmq-server
	root@verifier:# systemctl start rabbitmq-server
	```
If you start the `rabbitmq-server`, your rabbit node should now be rabbit@myhost, as verified by _rabbitmqctl_:
	```bash
	root@verifier:# rabbitmqctl status
	```
If you need to stop the rabbitmq server, just run:
	```bash
	root@verifier:# rabbitmqctl stop
	```

20. after `rabbitmq-server` is running, you can configure Celery in `/BASEDIR/verifier/ram/config.py` and `/BASEDIR/verifier/ram/celeryconfig.py`.
In `celeryconfig.py`, you can change the periodic attestation frequency. In `config.py`, you can change the OpenAttestation related parameters, especially `OAT_NODE`, `OAT_VERIFIER` and `OAT_LEVEL`. Also, the new certificate generated by OpenAttestation (i.e. certfile.cer) needs to be copied from the `BASEDIR/verifier/OpenAttestation/CommandTool` into `data` directory to replace the old one.
Then copy `/BASEDIR/verifier/ram` to `/home/user/ram` and start the periodic task with user account.

	```bash
	root@verifier:# cp /BASEDIR/verifier/OpenAttestation/CommandTool/certfile.cer /BASEDIR/verifier/ram/data/certfile.cer
	root@verifier:# cp -r /BASEDIR/verifier/ram /home/user/ram
	root@verifier:# su user
	user@verifier:$ cd /home/user/ram
	user@verifier:$ celery -A tasks worker --beat &
	```
In order for OpenAttestation to know the certificate used by strongswan in the node to authenticate itself, when the node is registering to the verifier, it also needs to input the digest of the file containing his certificate (i.e. [`peerCert.der`](https://gitlab.secured-fp7.eu/secured/ned/tree/strongswan/strongswan) step 6 in NED repository) along with it, see [step 7](https://gitlab.secured-fp7.eu/secured/verifier/blob/devel/README.md) in verifier repository.
When node revokes its certificate, it needs to be re-registered again, with the digest of the certificate, with the _update_cert.sh_ script in `/BASEDIR/verifier/OpenAttestation/CommandTool` directory.
	
21. The web service created by OpenAttestation, running by _httpd_, the configuration files are in `/etc/httpd/conf.d`, need to change `ssl.conf` by adding new ServerName attribute `ServerName verifier:443`, and need to copy `tossl.conf` to the same `/etc/httpd/conf.d` directory. And the web page for user to read the attestation result changes to _https://verifier/OAT/result.php?CN=node2&LEVEL=4&DGST=8b71648e9c52a24cfe259305c611483ea56ca4dc_, it will provide the same result as it was. 
The REST API has also changed from `http` to `https`, the new URL to the REST API is `https://verifier/OAT/attest.php`.

22. if OpenAttestation has been installed and running correctly, just need to copy the new php files in the `/BASEDIR/verifier/OpenAttestation/Source/Portal` directory into `/var/www/html/OAT` directory.

23. in order to register multiple nodes into this verifier, need to run the steps defined in `NED setup` in the NED README. Afterward, need to run `add_NED.sh` in the `/BASEDIR/verifier/OpenAttestation/CommandTool` directory as following.

	``` bash
	user@verifier$ bash add_NED.sh $selfname $attestorname $attestorIP $PCR0value $OSdistname $CERTDGST
	```
example: 
    ```bash 
    add_NED.sh verifier ned2 xxx.xxx.xxx.xxx 7D94A15BE0295A3743FC259B07202FF42550B369 CentOS7 8b71648e9c52a24cfe259305c611483ea56ca4dc
    ```	
Then the new node's name needs to be inserted into the `OAT_NODE` variable in `BASEDIR/verifier/ram/config.py` file.

In the case that the following error exists `SQL Error: 0, SQLState: 22001`, it is because the `- Data truncation: Data too long for column 'report' at row 1`. You can follow this page to solve the problem. `https://www.w3schools.com/sql/sql_alter.asp` to change the `report` type to `longtext`. (I have made this change in the latest OAT source code).


## Example
You need to change the node's cert_digest.

Open _https://verifier/OAT/result.php?CN=node2&LEVEL=4&DGST=8b71648e9c52a24cfe259305c611483ea56ca4dc_ with a browser to see the attestation result.

* CN is the common name of the node
* LEVEL is the trust level of the requirement
* DGST is the digest of the strongSwan certificate used by the node

Or send POST requests to `https://verifier/OAT/attest.php`:

	```bash
	user@verifier:$ PDATA='{"hosts":["node"],"analysisType":"load-time+check-cert,l_req=l4_ima_all_ok|>=,cert_digest=efae492da504edea2c2358dea1fb1e6770780b6e"}'
	user@verifier:$ curl -XPOST -H "Content-Type:application/json" -d "$PDATA" https://verifier/OAT/attest.php
	```
You need to change the node's cert_digest.
Response is a JSON message structed as following:
Responses will be a JSON message structured as follow:

```json
{
	"status": "success",
	"n_results": 1,
	"results":[
		{
			"trust_lvl": "trusted",
			"host_name": "node"
		},
	]
}
```


# Attester
In the attester, it is possible to use multiple Linux distributions, the supported distributions should include Fedora, CentOS and Ubuntu. The problem is if the IMA reference database for the distribution can be created or not. As far as I tested, the scripts to create reference database of CentOS and Fedora are working correctly, but the one to create reference database of Ubuntu is not working. Paolo has done some work to this problem, please refer to him for further information.

The RA agent uses trousers to interact with the TPM, tcsd and tcsd-devel in CentOS/Fedora, trousers and libtspi-dev in Ubuntu.

Hereafter the attester is depolyed with CentOS7.

## Dependencies
    yum install bzip2 wget gcc gmp-devel unzip trousers automake \
    autoconf libtool pkg-config gettext perl python flex bison \
    gperf trousers-devel java-1.7.0-openjdk java-1.7.0-openjdk-devel\ 
    patch elfutils-libelf-devel bc gcc ncurses-devel openssl-devel
    
## Installation steps   
Step 1, 2, 3, 8, 9 are for remote attestation feature, they work with the verifier. Step 4, 5, 6, 7 are for installing and configuring strongswan ipsec connection.

1. map the host names with the hardcoded IP addresses;
2. activate TPM from BIOS and start the tcsd service;

	```bash
	root@node: # systemctl start tcsd
	root@node: # systemctl enable tcsd
	```
3. download the ClientInstallForLinux.zip to register the machine to the verifier;

    ```bash
    root@node: # wget http://verifier/ClientInstallForLinux.zip

    root@node: # unzip ClientInstallForLinux.zip

    root@node: # cd ClientInstallForLinux

    root@node: # sh genera-install.sh
    ```

4. install strongswan from source;

    ```bash
    root@node: # cd strongswan-5.3.2

    root@node: # autoreconf -i

    root@node: # ./configure --with-ipsecdir=/usr/libexec/strongswan --bindir=/usr/libexec/strongswan --sysconfdir=/etc/strongswan \
		    --enable-dhcp --enable-farp --enable-openssl --enable-eap-md5

    root@node: # make && make install
    ```


5. open port for ipsec to communicate with userterminal;

    ```bash
    root@node: # firewall-cmd --permanent --add-port=500/udp

    root@node: # firewall-cmd --permanent --add-port=4500/udp

    root@node: # firewall-cmd --add-port=4500/udp

    root@node: # firewall-cmd --add-port=500/udp
    ```
6. generate certificates for CA, peer, and client;

    ```bash
    root@node: # /usr/libexec/strongswan/pki --gen > caKey.der

    root@node: # /usr/libexec/strongswan/pki  --self --in caKey.der --dn "C=CH, O=strongSwan, CN=strongSwan CA" --ca --outform pem > caCert.crt

    root@node: # /usr/libexec/strongswan/pki  --gen > peerKey.der

    root@node: # /usr/libexec/strongswan/pki --pub --in peerKey.der | /usr/libexec/strongswan/pki --issue --cacert caCert.crt --cakey caKey.der --dn "C=CH, O=strongSwan, CN=node" --san xxx.xxx.xxx.xxx > peerCert.der
    ```
    xxx.xxx.xxx.xxx is the ip of the node, which is needed for the Android strongswan application.

7. copy each certificate to the corresponding folders in both node and userterminal;

    ```bash
    root@node: # cp caCert.crt /etc/strongswan/ipsec.d/cacerts

    root@node: # cp peerCert.der /etc/strongswan/ipsec.d/certs/

    root@node: # cp peerKey.der /etc/strongswan/ipsec.d/private/

    root@node: # scp caCert.crt root@userterminal:/etc/strongswan/ipsec.d/cacerts
    ```

8. read PCR0 from the TPM and register it with the configure script to the verifier;

	the file storing the PCR values is called 'pcrs', it is stored in /sys/devices/pnp0 subdirectory, need to have a search before determine the exact location. The commands below is only one example.

	```bash
	root@node: # cd /sys/devices/pnp0

	root@node: # find . -iname "pcrs"

	root@node: # cat 00:0a/pcrs | sed "s/ //g"
	```
	you should see the output as:

	```bash
	PCR-00:062AC3E7639E58B5F8919743C9AD1172A6A0CE2C
	PCR-01:B2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
	PCR-02:B2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
	PCR-03:B2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
	PCR-04:B35D3B46BB9C22038A8C6C5CF695690F5AAF0E38
	PCR-05:239443EC48A427DDE7CDED2A21CBDB45EC327BDD
	PCR-06:B2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
	PCR-07:B2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
	PCR-08:0000000000000000000000000000000000000000
	PCR-09:0000000000000000000000000000000000000000
	PCR-10:CFB2CCC82A6779E608CBF578AB803251C49DF047
	PCR-11:0000000000000000000000000000000000000000
	PCR-12:0000000000000000000000000000000000000000
	PCR-13:0000000000000000000000000000000000000000
	PCR-14:0000000000000000000000000000000000000000
	PCR-15:0000000000000000000000000000000000000000
	PCR-16:0000000000000000000000000000000000000000
	PCR-17:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-18:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-19:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-20:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-21:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-22:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	PCR-23:0000000000000000000000000000000000000000
	```
	afterwards, need to input the PCR0 value to the verifier as shown in [verifier README step 7](https://gitlab.secured-fp7.eu/secured/verifier/blob/devel/README.md "verifier").

9. to attest the certificate, a trick is needed, to create a temp user, and assign the certificate with him, then set the ima policy to attest the files belonging to this user;

	read the temp user's uid using "id -u temp" as tUID.

	```bash
	root@node: # adduser -s /bin/false temp
	root@node: # chown temp /etc/strongswan/ipsec.d/certs/peerCert.der
	root@node: # mkdir /etc/ima
	root@node: # cp ima-policy /etc/ima
	root@node: # echo -e "measure fowner=$tUID" >> /etc/ima/ima-policy
	```

10. copy the ipsec configuration files in the ipsec directory to /etc/strongswan/

	ipsec.secrests is ready for use, you can change the password inside if you want. ipsec.conf needs to be modified based on specific settings, especially the ip addresses.

	you can follow the descriptions in [strongswan ipsec.conf](https://wiki.strongswan.org/projects/strongswan/wiki/ConnSection) to customise your ipsec configurations.

11. run strongswan;

	```bash
	root@node: # systemctl start strongswan

	root@node: # systemctl enable strongswan

	root@node: # reboot
	```

12. in order to use Docker attestation, the original IMA need to be extended. The patch to IMA is called `ima.patch`.
The step to apply the patch and compile the kernel is 

	```bash
	root@node: # tar -xf linux-version.tar.xz
	
	root@node: # cd linux-version
	
	root@node: # patch -p1 < ima.patch
	
	root@node: # cp /boot/config-theoriginalosversion .config
	
	root@node: # make menuconfig

	root@node: # make -j5

	root@node: # make modules_install

	root@node: # make install 

	root@node: # reboot
	```

At this point, with some luck, the os will boot correctly and the boot configuration is applied in the new kernel.

13. In order to use Docker, remember to change the flag of `AddContainerAnalysisSupport` to True in `/OAT/OAT.properties`. 

14. Also, the `ima_template` value in the boot option needs to be changed to the new template called `ima-cont-id`.

15. The currently the working Docker version is `docker-engine-1.9.1-1.el7.centos` and `docker-engine-selinux-1.9.1-1.el7.centos.noarch`. There is a student working on the same solution to the later version of Docker, Marco should have the information.  

# Tricks and FAQ

- how to update hashes of a distro: 

	The official way to update the hashes of a distro is:
	
	```bash 
	root@verifier: # bash update_pkgs.sh
	```
	with the configurations stored in `/etc/ra/pkgs_download_list.conf`. 
	
	If there is only one package needs to be inserted into the refereence database, you can use the python module to operate directly in the reference database as following:
	
	```python
	python
	import pycassa
	cassandra_url = "127.0.0.1"
	keyspace = "PackagesDB"
	client = pycassa.ConnectionPool(keyspace, [cassandra_url], pool_timeout = -1, max_retries = -1)
	column_path_packagesh = pycassa.ColumnFamily(client,'PackagesHistory')
	package_source_name = "curl"
	distname = "CentOS7"
	package_source_pkeyver = "7.32.0-11.fc20"
	column_path_packagesh.insert(package_source_name + '-' + distname, { package_source_pkeyver : { 'name' : package_source_name + '-' + package_source_pkeyver } } )
	column_path_packagesh.insert(package_source_name + '-' + distname, { package_source_pkeyver : { 'updatetype': 'security' } } )
	column_path_packagesh.get('curl-CentOS7')
	```

- how to reset the TPM

	Depending on the TPM manufacture, there are different ways to reset the TPM. Either it is possible to use software to reset it, e.g. `tpm_clear` in tpm_tools package or it requires to change the jumper in the motherboard to reset the TPM. 
	
- how to deal with error 14 and 16 when launching the `general-install.sh`

	Error 16 means the persistent memory does not allow data from outside the TPM to store inside. So the AIK certificate cannot be stored inside the TPM, so it must be saved outside with:
	
	```bash 
	sh general-install.sh -ecs file
	```
	
	Error 14 means the TPM ownership has been taken, and it requires to reset the TPM to solve this problem. 
